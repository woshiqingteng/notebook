Linux命令行与shell脚本编程大全
第二部分 shell脚本编程基础

[TOC]

# 第二部分 shell脚本编程基础

## 第11章 构建基本脚本
* 使用多个命令
* 创建shell脚本
  ```shell
  #!/bin/bash 
  # This script displays the date and who's logged on
  date
  who

  ls -l test1
  chmod u+x test1
  ./test1
  ```
* 显示消息
  ```shell
  #!/bin/bash 
  # This script displays the date and who's logged on
  echo -n "The time and date are:"
  date
  echo "Let's see who's logged into the system:"
  who  

  chmod u+x test1
  ./test1
  ```
* 使用变量
  * 环境变量
  ```shell
  #!/bin/bash
  # display user information from the system.
  echo "User info for userid: $USER"
  echo UID: $UID
  echo HOME: $HOME
  
  chmod u+x test2
  ./test2
  echo "The cost of the item is \$15"
  ```
  * 用户变量
  ```shell
  #!/bin/bash
  # testing variables
  days=10
  guest="Katie"
  echo "$guest checked in $days days ago"
  days=5
  guest="Jessica"
  echo "$guest checked in $days days ago"

  chmod u+x test3
  ./test3

  #!/bin/bash
  # assigning a variable value to another variable 
  value1=10
  value2=$value1
  echo The resulting value is $value2

  chmod u+x test4
  ./test4 
  ```  
  * 命令替换
  ```shell
  反引号字符`
  $()格式
  testing=`date`
  testing=$(date)

  #!/bin/bash 
  testing=$(date)
  echo "The date and time are: " $testing

  chmod u+x test5
  ./test5

  #!/bin/bash
  # copy the /usr/bin directory listing to a log file
  today=$(date +%y%m%d)
  ls /usr/bin/ -al > log.$today
  ```
* 重定向输入和输出
  * 输出重定向
    ```shell
    command > outputfile # 输出发送到一个文件
    date > test6
    ls -l test6
    who > test6 # 输出文件已存在，重定向操作符新文件数据覆盖已有文件
    cat test6
    date >> test6 # >>输出追加已有文件
    cat test6
    ```
  * 输入重定向
    ```shell
    command < inputfile # 文件内容重定向命令
    wc < test6 # wc=对数据文本计数：文本行数、文本次数、文本字节数
    command << marker # 内联输入重定向(inline input redirection) 
    data
    marker

    wc << EOF
    test string 1
    test string 2
    test string 3
    EOF
    ```
* 管道
  ```shell
  command1 | command2 # 第一个命令产生输出同时，输出被送往第二个命令
  rpm -qa | sort
  rpm -qa | sort | more
  rpm -qa | sort > rpm.list
  ```
* 执行数学运算
  * expr命令
    ```shell
    expr 1 + 5
    expr 5 \* 2

    #!/bin/bash
    # An example of using the expr command
    var1=10
    var2=20
    var3=$(expr $var2 / $var1)
    echo The result is $var3
    ```
  * 使用方括号
    ```shell
    var1=$[1 + 5]
    echo $var1
    var2=$[$var1 * 2]
    echo $var2

    #!/bin/bash
    var1=100
    var2=50
    var3=45
    var4=$[$var1 * ($var2 - $var3)]
    echo The final result is $var4

    chmod u+x test7
    ./test7

    #!/bin/bash
    var1=100
    var2=45
    var3=$[$var1 / $var2]
    echo The final result is $var3

    chmod u+x test8
    ./test8 # bash shell只支持整数运算，zsh支持完整浮点数算数运算
    ```
  * 浮点数解决方案
    ```shell
    bc 
    12 * 5.4
    3.156 * (3 + 5)
    quit

    bc -q # -q不显示bash计算器欢迎信息
    3.44 / 5
    scale=4 # 设置保留小数位数，默认为0
    3.44 / 5
    quit

    bc -q
    var1=10 # 支持变量
    var1 * 4
    var2 = var1 / 5
    print var2
    quit

    variable=$(echo "options; expression" | bc)
    #!/bin/bash
    var1=$(echo "scale=4; 3.44 / 5" | bc)
    echo The answer is $var1

    chmod u+x test9
    ./test9

    #!/bin/bash
    var1=100
    var2=45
    var3=$(echo "scale=4; $var1 / $var2" | bc)
    echo The answer for this is $var3

    chmod u+x test10
    ./test10

    #!/bin/bash
    var1=20
    var2=3.14159
    var3=$(echo "scale=4; $var1 * $var1" | bc)
    var4=$(echo "scale=4; $var3 * $var2" | bc)
    echo The final result is $var4

    chmod u+x test11
    ./test11

    variable=$(bc << EOF
    options
    statements
    expressionEOF
    )

    #!/bin/bash
    var1=10.46
    var2=43.67
    var3=33.2
    var4=71
    var5=$(bc << EOF
    scale = 4
    a1 = ( $var1 * $var2)
    b1 = ( $var3 * $var4)
    a1 + b1
    EOF
    )
    echo The final answer for this is $var5

    chmod u+x test12
    ./test12
    ```
* 退出脚本
  * 查看退出状态码
    ```shell
    date
    echo $? # 成功命令退出码0
    asdfg
    echo $? # 无效命令返回退出码127
    ./myprog.c
    echo $? # 没有执行命令权限退出码126
    date %t
    echo $? # 一般性未知错误退出码1
    ```
  * exit命令
    ```shell
    #!/bin/bash
    # testing the exit status
    var1=10
    var2=30
    var3=$[$var1 + $var2]
    echo The answer is $var3
    exit 5

    chmod u+x test13
    ./test13
    echo $?

    #!/bin/bash
    # testing the exit status
    var1=10
    var2=30
    var3=$[$var1 + $var2]
    exit $var3

    chmod u+x test14
    ./test14
    echo $?

    #!/bin/bash
    # testing the exit status
    var1=10
    var2=30
    var3=$[$var1 * $var2]
    echo The value is $var3
    exit $var3

    chmod u+x test14b
    ./test14b
    echo $? # 300除256取余得44
    ```

## 第12章 使用结构化命令
* 使用if-then语句
  ```shell
  if command
  then
      commands
  fi
  # if语句运行if后面命令
  # if后命令退出状态码为0(该命令成功运行)，位于then后命令执行，
  # 如果该命令退出码是其他值，then部分命令不执行，bash shell继续执行脚本下一个命令
  # fi表示if-then语句到此结束
  if command; then
  commands
  fi
  # if-then另一种形式

  #!/bin/bash
  # testing the if statements
  if pwd
  then
      echo "It worked"
  fi

  chmod u+x test1.sh
  ./test1.sh

  #!/bin/bash
  # testing a bad command
  if IamNotaCommand
  then
      echo "It worked"
  fi
  echo "We are outside the if statement"

  chmod u+x test2.sh
  ./test2.sh

  #!/bin/bash
  # testing multiple commands in the then section
  #
  testuser=Christine # Christine替换NoSuchUser，什么都不显示
  #
  if grep $testuser /etc/passwd
  then
      echo "This is my first command"
      echo "This is my second command"
      echo "I can even put in other commands besides echo:"
      ls -a /home/$testuser/.b*
  fi

  chmod u+x test3.sh
  ./test3.sh
  ```
* if-then-else语句
  ```shell
  #!/bin/bash
  # testing multiple commands in the then section
  #
  testuser=NoSuchUser 
  #
  if grep $testuser /etc/passwd
  then
      echo "This bash files for user $testuser are:"
      ls -a /home/$testuser/.b*
      echo
  else
      echo "The uesr $testuser does not exist on this system."
      echo
  fi

  chmod u+x test4.sh
  ./test4.sh
  ```
* 嵌套if
  ```shell
  ls -d /home/NoSuchUser/
  #!/bin/bash
  # Testing nested ifs
  #
  testuser=NoSuchUser 
  #
  if grep $testuser /etc/passwd
  then
      echo "The uesr $testuser exists on this system."
  else
      echo "The uesr $testuser does not exist on this system."
      if ls -d /home/$testuser
      then
          echo "However, $testuser has a directory."
      fi
  fi

  chmod u+x test5.sh
  ./test5.sh

  if command1
  then
      commands
  elif command2
  then
      more commands
  fi
  # elif使用另一个if-then延续else部分

  #!/bin/bash
  # Testing nested ifs - use elif
  #
  testuser=NoSuchUser 
  #
  if grep $testuser /etc/passwd
  then
      echo "The uesr $testuser exists on this system."
  #
  elif ls -d /home/$testuser
  then
      echo "The uesr $testuser does not exist on this system."
      echo "However, $testuser has a directory."
  #
  fi

  ./test5.sh

  #!/bin/bash
  # Testing nested ifs - use elif & else
  #
  testuser=NoSuchUser 
  #
  if grep $testuser /etc/passwd
  then
      echo "The uesr $testuser exists on this system."
  #
  elif ls -d /home/$testuser
  then
      echo "The uesr $testuser does not exist on this system."
      echo "However, $testuser has a directory."
  #
  else
      echo "The uesr $testuser does not exist on this system."
      echo "And, $testuser does not have a directory."
  fi

  ./test5.sh
  sudo rmdir /home/NoSuchUser
  ./test5.sh

  if command1
  then
      command set 1
  elif command2
  then
      command set 2
  elif command3
  then
      command set 3
  elif command4
  then
      command set 4
  fi
  ```
* test命令
  ```shell
  test condition # test命令列出条件成立，test命令退出并返回退出状态码0
                 # 如果条件不成立，test命令退出并返回非零退出状态码，使if-then语句不执行

  if test condition
  then
      commands
  fi
  # 不写test命令的condition部分，以非零状态码退出，并执行else语句块

  #!/bin/bash
  # Testing the test command
  #
  if test
  then
      echo "No expression returns a True"
  else
      echo "No expression returns a False"
  fi

  chmod u+x test6.sh
  ./test6.sh

  #!/bin/bash
  # Testing the test command
  #
  my_variable="Full"
  #
  if test $my_variable
  then
      echo "The $my_variable expression returns a True"
  else
      echo "The $my_variable expression returns a False"
  fi

  ./test6.sh

  #!/bin/bash
  # Testing the test command
  #
  my_variable=""
  #
  if test $my_variable
  then
      echo "The $my_variable expression returns a True"
  else
      echo "The $my_variable expression returns a False"
  fi

  ./test6.sh

  if [ condition ]
  then
      commands
  fi
  # 另一种条件测试方法，无需在if-then中声明test命令
  # 第一个方括号之后和第二个方括号之前必须加上一个空格
  # test命令判断三类条件:数值比较、字符串比较、文件比较
  ```
  * 数值比较
    ```shell
    #!/bin/bash
    # Using numeric test evaluations
    #
    value1=10
    value2=11
    #
    if [ $value1 -gt 5 ]
    then
        echo "The test value $value1 is greater than 5"
    fi
    #
    if [ $value1 -eq $value2 ]
    then
        echo "The values are equal"
    else
        echo "The values are different"
    fi
    #

    chmod u+x numeric_test.sh
    ./numeric_test

    #!/bin/bash
    # Using floating point numbers in test evaluations
    #
    value1=5.555
    #
    echo "The test value is $value1"
    #
    if [ $value1 -gt 5 ]
    then
        echo "The test value $value1 is greater than 5"
    fi
    #

    chmod u+x floating_point_test.sh
    ./floating_point_test # bash shell只能处理整数
    ```
  * 字符串比较
    * 字符串相等性
      ```shell
      #!/bin/bash
      # testing string equality
      testuser=rich
      #
      if [ $USER = $testuser ]
      then
          echo "Welcome $testuser"
      fi

      chmod u+x test7.sh
      ./test7.sh

      #!/bin/bash
      # testing string equality
      testuser=baduser
      #
      if [ $USER != $testuser ]
      then
          echo "This is not $testuser"
      else
          echo "Welcome $testuser"
      fi

      chmod u+x test8.sh
      ./test8.sh
      ```
    * 字符串顺序
      ```shell
      # 大于号和小于号必须转义，否者shell当成重定向符号，把字符串值当成文件名
      # 大于和小于顺序和sort命令采用不同

      #!/bin/bash
      # mis-using string comparisons
      #
      var1=baseball
      var2=hockey
      #
      if [ $var1 \> $var2 ]
      then
          echo "$var1 is greater than $var2"
      else
          echo "$var1 is less than $var2"
      fi

      chmod u+x test9.sh
      ./test9.sh

      #!/bin/bash
      # testing string sort order
      var1=Testing
      var2=testing
      #
      if [ $var1 \> $var2 ]
      then
          echo "$var1 is greater than $var2"
      else
          echo "$var1 is less than $var2"
      fi

      chmod u+x test9b.sh
      ./test9b.sh

      sort testfile # 
      ```
    * 字符串大小
      ```shell
      #!/bin/bash
      # testing string length
      var1=testing
      var2=''
      #
      if [ -n $var1 ]
      then
          echo "The string '$var1' is not empty"
      else
          echo "The string '$var1' is empty"
      fi
      #
      if [ -z $var2 ]
      then
          echo "The string '$var2' is not empty"
      else
          echo "The string '$var2' is empty"
      fi
      #
      if [ -z $var3] 
      then
          echo "The string '$var3' is not empty"
      else
          echo "The string '$var3' is empty"
      fi

      chmod u+x test10.sh
      ./test10.sh


      ```
    * 文件比较
      * 检查目录
        ```shell
        #!/bin/bash
        # Look before you leap
        #
        jump_directory=/home/arthur
        #
        if [ -d $jump_directory ]
        then
            echo "The $jump_directory directory exists"
            cd $jump_directory
            ls
        else
            echo "The $jump_directory directory does not exist"
        fi

        chmod u+x test11.sh
        ./tets11.sh
        ```
      * 检查对象是否存在
        ```shell
        #!/bin/bash
        # Check if either a directory or file exists
        #
        location=$HOME
        file_name="sentinel"
        #
        if [ -e $location ]
        then # Directory does exist
            echo "OK on the $location directory."
            echo "Now checking on the file, $file_name."
            #
            if [ -e $location/$file_name ]
            then # File does exist
                echo "OK on the filename"
                echo "Updating Current Date..."
                date >> $location/$file_name
            #
            else # File does not exist
                echo "File does not exist"
                echo "Nothing to update"
            fi
        #
        else # Directory does not exist
            echo "The $location directory does not exist."
            echo "Nothing to update"
        fi
        #

        chmod u+x test12.sh
        ./test12.sh

        touch sentinel
        ./test12.sh
        ```
      
      * 检查文件
        ```shell
        #!/bin/bash
        # Check if either a directory or file exists
        #
        item_name=$HOME
        echo
        echo "The item being checked: $item_name"
        echo
        #
        if [ -e $item_name ]
        then # Item does exist
            echo "The item, $item_name, does exist."
            echo "But is it a file?"
            echo
            #
            if [ -f $item_name ]
            then # Item is a file
                echo "Yes, $item_name is a file."
                echo
            #
            else # Item is not a file
                echo "No, $item_name is not a file."
            fi
        #
        else # Item does not exist
            echo "The item, $item_name, does not exist."
            echo "Nothing to update"
        fi
        #

        chmod u+x test13.sh
        ./test13.sh

        # 将$HOME替换为$HOME/sentinel
        ./test13.sh
        ```
      * 检查是否可读
        ```shell
        #!/bin/bash
        # testing if you can read a file
        pwfile=/etc/shadow
        #
        # first, test if the file exists, and is a file
        if [ -f $pwfile ]
        then
            # now test if you can read It
            if [ -r $pwfile ]
            then
                tail $pwfile
            else
                echo "Sorry, I am unable to read the $pwfile file"
            fi
        else
            echo "Sorry, the file $pwfile does not exist"
        fi

        chmod u+x test14.sh
        ./test14.sh
        ```
      * 检查空文件
        ```shell
        #!/bin/bash
        # Testing if file is empty
        #
        file_name=$HOME/sentinel
        #
        if [ -f $file_name ]
        then
            if [ -s $file_name ]
            then
                echo "The $file_name file exists and has data in it."
                echo "Will not remove this file."
        #
            else
                echo "The $file_name file exists, but is empty."
                echo "Deleting empty file..."
                rm $file_name
            fi
        else
            echo "File, $file_name, does not exist."
        fi

        ls -l $HOME/sentinel
        chmod u+x test15.sh
        ./test15.sh
        ```
      * 检查是否可写
        ```shell
        #!/bin/bash
        # Check if a file is writable
        #
        item_name=$HOME/sentinel
        echo
        echo "The item being checked: $item_name"
        echo
        #
        if [ -e $item_name ]
        then # Item does exist
            echo "The item, $item_name, does exist."
            echo "But is it a file?"
            echo
            #
            if [ -f $item_name ]
            then # Item is a file
                echo "Yes, $item_name is a file."
                echo "But is it writable?"
                echo
                #
                if [ -w $item_name ]
                then # Item is writable
                    echo "Writing current time to $item_name"
                    date +%H%M >> $item_name
                #
                else # Item is not writable
                    echo "Unable to write to $item_name"
                fi
            #
            else # Item is not a file
                echo "No, $item_name is not a file."
            fi
        #
        else # Item does not exist
            echo "The item, $item_name, does not exist."
            echo "Nothing to update"
        fi
        #
        
        ls -l sentinel
        chmod u+x test16.sh
        ./test16.sh
        cat sentinel
        chmod u-w sentinel
        ls -l sentinel
        ./test16.sh
        ```
      * 检查文件是否可以执行
        ```shell
        #!/bin/bash
        # testing file execution
        #
        if [ -x test16.sh ]
        then
            echo "You can run the script:"
            ./test16.sh
        else
            echo "Sorry, you are unable to execute the script"
        fi

        chmod u+x test17.sh
        ./test17
        chmod u-x test16.sh
        ./test17.sh
        ```
      * 检查所属关系
        ```shell
        #!/bin/bash
        # check file ownship
        #
        if [ -O /etc/passwd ]
        then
            echo "You are the owner of the /etc/passwd file"
        else
            echo "Sorry, you are not the owner of the /etc/passwd file"
        fi

        chmod u+x test18.sh
        ./test18.sh
        ```
      * 检查默认组关系
        ```shell
        #!/bin/bash
        # check file group test
        #
        if [ -G $HOME/testing ]
        then
            echo "You are in the same group as the file"
        else
            echo "The file is not owned by your group"
        fi

        ls -l $HOME/testing
        ./test19.sh
        chgrp sharing $HOME/testing
        ./testing19.sh

        ```
      * 检查文件日期
        ```shell
        #!/bin/bash
        # testing file dates
        #
        if [ test19.sh -nt test18.sh ]
        then
            echo "The test19 file is newer than test18"
        else
            echo "The test18 file is newer than test19"
        fi
        if [ test17.sh -ot test19.sh ]
        then
            echo "The test17 file is older than the test19 file"
        fi

        chmod u+x test20.sh
        ./test20.sh
        ls -l test17.sh test18.sh test19.sh

        #!/bin/bash
        # testing file dates
        #
        if [ badfile1 -nt badfile2 ]
        then
            echo "The badfile1 file is newer than badfile2"
        else
            echo "The badfile2 file is newer than badfile1"
        fi

        chmod u+x test21.sh
        ./test21.sh # 文件不存在-nt返回错误结果
        ```
* 复合条件从测试
  ```shell
  [ condition1 ] && [ condition2 ] # AND布尔算数符
  [ condition1 ] || [ condition2 ] # OR布尔算数符

  #!/bin/bash
  # testing compound comparisons
  #
  if [ -d $HOME ] && [ -w $HOME/testing ]
  then
      echo "The file exists and you can write to it"
  else
      echo "I cannot write to the file"
  fi

  chmod u+x test22.sh
  ./test22.sh
  ```
* if-than的高级特性
  用于数学表达式的双括号
  用于高级字符串处理功能的双方括号
  * 使用双括号
    ```shell
    (( expression )) # 格式

    #!/bin/bash
    # using double parenthesis
    #
    var1=10
    #
    if (( $var1 ** 2 > 90 ))
    then
        (( var2 = $var1 ** 2 ))
        echo "The square of $var1 is $var2"
    fi

    chmod u+x test23.sh
    ./test23.sh
    ```
  * 使用双方括号
    ```shell
    [[ expression ]] # 格式

    #!/bin/bash
    # using pattern matching
    #
    if [[ $USER == r* ]]
    then
        echo "Hello $USER"
    else
        echo "Sorry, I do not know you"
    fi

    chmod u+x test24.sh
    ./test24.sh
    ```
* case命令
  ```shell
  #!/bin/bash
  # looking for a possible value
  #
  if [ $USER = "rich" ]
  then
      echo "Welcome $USER"
      echo "Please enjoy your visit"
  elif [ $USER = "barbara" ]
  then
      echo "Welcome $USER"
      echo "Please enjoy your visit"
  elif [ $USER = "testing" ]
  then
      echo "Special testing account"
  elif [ $USER = "jessica" ]
  then
      echo "Do not forget to logout when you're done"
  else
      echo "Sorry, you are not allowed here"
  fi

  chmod u+x test25.sh
  ./test25.sh

  case variable in
  pattern1 | pattern2) commands1;;
  pattern3) commands2;;
  *) default commands;;
  esac
  # case命令格式

  #!/bin/bash
  # using the case command
  #
  case $USER in
  rich | barbara)
      echo "Welcome, $USER"
      echo "Please enjoy your visit";;
  testing)
      echo "Special testing account";;
  jessica)
      echo "Do not forget to log off when you're done";;
  *)
      echo "Sorry, you are not allowed here";
  esac

  chmod u+x test26.sh
  ./test26.sh
  ```



## 第13章 更多的结构化命令
* for命令
  ```shell
  for var in list # for var in list; do 也可放同一行
  do
      commands
  done
  ```
  * 读取列表中的值
    ```shell
    #!/bin/bash
    # basic for command
    for test in Alabama Alaska Arizona Arkansas California Colorado
    do
        echo The next state is $test
    done

    chmod u+x test1
    ./test1

    #!/bin/bash
    # testing the for variable after the looping
    for test in Alabama Alaska Arizona Arkansas California Colorado
    do
        echo "The next state is $test"
    done
    echo "The last state we visited was $test"
    test=Connecticut
    echo "Wait, now we're visiting $test"

    chmod u+x test1b
    ./test1b
    ```
  * 读取列表中的复杂
    ```shell
    #!/bin/bash
    # another example of how not to use the for command
    for test in I don\'t know if "this'll" work
    do
        echo "word:$test"
    done

    chmod u+x test2
    ./test2 # 列表值中单引号使用转移字符或双引号

    #!/bin/bash
    # an example of how to properly define values
    for test in Nevada "New Hampshire" "New Mexico" "New York"
    do
        echo "Now going to $test"
    done

    chmod u+x test3
    ./test3 # for用空格划分列表值，单独数据有空格双引号括起来
    ```
  * 从变量读取列表
    ```shell
    #!/bin/bash
    # using a variable to hold the list
    list="Alabama Alaska Arizona Arkansas Colorado"
    list=$list" Connecticut"
    for state in $list
    do
        echo "Have you ever visited $state?"
    done

    chmod u+x test4
    ./test4
    ```
  * 从命令读取值
    ```shell
    #!/bin/bash
    # reading values from a file
    file="states"
    for state in $(cat $file)
    do
        echo "Visit beautiful $state"
    done

    cat states
    chmod u+x test5
    ./test5
    ```
  * 更改字段分隔符
    ```shell
    # 内部字段分隔符(internal field separator,IFS)
    # 默认情况，bash shell将空格。制表符、换行符当做字段分隔符
    #!/bin/bash
    # reading values from a file
    file="states"
    IFS=$'\n'
    for state in $(cat $file)
    do
        echo "Visit beautiful $state"
    done

    chmod u+x test5b
    ./test5b

    IFS=: # 冒号分隔
    IFS=$'\n':;" # 多个IFS字符
    ```
  * 用通配符读取目录
    ```shell
    #!/bin/bash
    # iterate through all the files in a directory
    for file in /home/rich/test/*
    do
        if [ -d "$file" ] # 目录名或文件名可能含空格，加双引号
        then
            echo "$file is a directory"
        elif [ -f "$file" ]
        then
            echo "$file is a file"
        fi
    done

    chmod u+x test6
    ./test6

    #!/bin/bash
    # iterating through multiple directorys
    for file in /home/rich/.b* /home/rich/badtest
    do
        if [ -d "$file" ]
        then
            echo "$file is a directory"
        elif [ -f "$file" ]
        then
            echo "$file is a file"
        else
            echo "$file doesn't exist"
        fi
    done

    chmod u+x test7
    ./test7
    ```
* C语言风格的for命令
  * C语言的for命令
    ```shell
    for (( variable assignment ; condition ; iteration process ))
    # 有些没有遵守bash shell标准for命令
    # 变量复制可以有空格；条件中变量不以美元符开头；迭代过程算式未用expr命令格式

    #!/bin/bash
    # testing the C-style for loop
    for (( i=1; i <= 10; i++ ))
    do
        echo "The next number is $i"
    done

    chmod u+x test8
    ./test8
    ```
  * 使用多个变量
    ```shell
    #!/bin/bash
    # multiple variables
    for (( a=1, b=10; a <= 10; a++, b-- ))
    do
        echo "$a - $b"
    done

    chmod u+x test9
    ./test9 # 可使用多个变量，但只能在for循环定义一种条件
    ```
* while命令
  * while的基本格式
    ```shell
    while test command
    do
        other commands
    done

    #!/bin/bash
    # while test command
    var1=10
    while [ $var1 -gt 0 ]
    do
        echo $var1
        var1=$[ $var1 - 1 ] # $[]或$(()),算数运算
    done

    chmod u+x test10
    ./test10
    ```
  * 使用多个测试命令
    ```shell
    #!/bin/bash
    # testing a multicommand while loop
    var1=10
    while echo $var1
            [ $var1 -ge 0 ]
    do
        echo "This is inside the loop"
        var1=$[ $var1 - 1 ]
    done

    chmod u+x test11
    ./test11

    # while定义多个测试命令，最后一个测试命令退出状态码被用来决定是否结束循环
    ```  
* until命令
  ```shell
  until test commands
  do
      other commands
  done

  #!/bin/bash
  # using the until command
  var1=100
  until [ $var1 -eq 0 ]
  do
      echo $var1
      var1=$[ $var1 -25 ]
  done

  chmod u+x test12
  ./test12

  #!/bin/bash
  # using the until command
  var1=100
  until echo $var1
        [ $var1 -eq 0 ]
  do
      echo Inside the loop: $var1
      var1=$[ $var1 -25 ]
  done

  chmod u+x test13
  ./test13 # 多个测试命令，只有在最后一个命令成立时停止
  ```
* 嵌套循环
  ```shell
  #!/bin/bash
  # nesting for loops
  for (( a = 1; a <= 3; a++ ))
  do
      echo "Starting loop $a:"
      for (( b = 1; b <= 3; b++ ))
      do
          echo "    Inside loop: $b"
      done
  done

  chmod u+x test14
  ./test14

  #!/bin/bash
  # placing a for loop inside a while loop
  var1=5
  while [ $var1 -ge 0 ]
  do
      echo "Outer loop: $var1"
      for (( var2 = 1; var2 < 3; var2++ ))
      do
      var3=$[ $var1 * $var2 ]
      echo "    Inner loop: $var1 * $var2 = $var3"
      done
      var1=$[ $var1 - 1 ]
  done

  chmod u+x test15
  ./test15

  #!/bin/bash
  # using until and while loops
  var1=3
  until [ $var1 -eq 0 ]
  do
      echo "Outer loop: $var1"
      var2=1
      while [ $var2 -lt 5 ]
      do
          var3=$(echo "scale=4; $var1 / $var2" | bc)
          echo "    Inner loop: $var1 / $var2 = $var3"
          var2=$[ $var2 + 1 ]
      done
      var1=$[ $var1 - 1 ]
  done

  chmod u+x test16
  ./test16
  ```
* 循环处理文件数据
  ```shell
  # 遍历存储在文件中的数据：使用嵌套循环、修改IFS环境变量

  #!/bin/bash
  # changing the IFS values
  IFS.OLD=$IFS
  IFS=$'\n'
  for entry in $(cat /etc/passwd)
  do
      echo "Values in $entry -"
      IFS=:
      for value in $entry
      do
          echo "    $value"
      done
  done
  ```
* 控制循环
  * break命令
    * 跳出单个循环
      ```shell
      #!/bin/bash
      # breaking out of a for loop
      for var1 in 1 2 3 4 5 6 7 8 9 10
      do
          if [ $var1 -eq 5 ]
          then
              break
          fi
          echo "Iteration number: $var1"
      done
      echo "The for loop is completed"

      chmod u+x test17
      ./test17

      #!/bin/bash
      # breaking out of a while loop
      var1=1
      while [ $var1 -lt 10 ]
      do
          if [ $var1 -eq 5 ]
          then
              break
          fi
          echo "Iteration: $var1"
          var1=$[ $var1 + 1 ]
      done
      echo "The while loop is completed"

      chmod u+x test18
      ./test18
      ```
    * 跳出内部循环
      ```shell
      #!/bin/bash
      # breaking out of an inner loop
      for (( a = 1; a < 4; a++ ))
      do
          echo "Outer loop: $a"
          for (( b = 1; b < 100; b++ ))
          do
              if [ $b -eq 5 ]
              then
                  break
              fi
              echo "    Inner loop: $b"
          done
      done

      chmod u+x test19
      ./test19
      ```
    * 跳出外部循环
      ```shell
      break n # 跳出的循环层级

      #!/bin/bash
      # breaking out of an outer loop
      for (( a = 1; b < 4; a++ ))
      do
          echo "Outer loop: $a"
          for (( b = 1; b < 100; b++ ))
          do
              if [ $b -gt 4 ]
              then
                  break 2
              fi
              echo "    Inner loop: $b"
          done
      done

      chmod u+x test20
      ./test20
      ```
  * continue命令
    ```shell
    #!/bin/bash
    # using the continue command
    for (( var1 = 1; var1 < 15; var1++ ))
    do
        if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
        then
            continue
        fi
        echo "Iteration number: $var1"
    done

    chmod u+x test12
    ./test12

    #!/bin/bash
    # improperly using the continue command in a while loop
    var1=0
    while echo "while iteration: $var1"
        [ $var1 -lt 15 ]
    do
        if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
        then
            continue
        fi
        echo "  Inside iteration number: $var1"
        var1=$[ $var1 + 1 ]
    done

    chmod u+x badtest3
    ./badtest3 | more  

    continue n 

    #!/bin/bash
    # continuing an outer loop
    for (( a = 1; a <= 5; a++ ))
    do
        echo "Iteration $a:"
        for (( b = 1; b < 3; b++ ))
        do
            if [ $a -gt 2 ] && [ $a -lt 4 ]
            then
                continue 2
            fi
            var3=$[ $a * $b ]
            echo "  The result of $a * $b is $var3"
        done
    done

    chmod u+x test22
    ./test22
    ```
* 处理循环的输出
  ```shell
  #!/bin/bash
  # redirecting the for output to a file
  for (( a = 1; a < 10; a++ ))
  do
      echo "The number is $a"
  done > test23.txt
  echo "The command is finished."

  chmod u+x test23
  ./test23
  cat test23.txt

  #!/bin/bash
  # piping a loop to another command
  for state in "North Dakota" Connecticut Illinois Alabama Tennessee
  do
      echo "$state is the next place to go"
  done | sort
  echo "This completes our travels"

  chmod u+x test24
  ./test24
  ```
* 实例
  * 查找可执行文件
    ```shell
    #!/bin/bash
    # finding files in the PATH
    IFS=:
    for folder in $PATH
    do
        echo "$folder:"
        for file in $folder/*
        do
            if [ -x $file ]
            then
                echo "  $file"
            fi
        done
    done

    chmod u+x test25
    ./test25 | more
    ```
  * 创建多个用户账号
    ```shell
    #!/bin/bash
    # process new user accounts
    input="users.csv"
    while IFS=',' read -r userid name
    do
        echo "adding $userid"
        useradd -c "$name" -m $userid
    done < "$input"

    chmod u+x test26
    sudo ./test26

    tail /etc/passwd
    ```
    
## 第14章 处理用户输入
* 命令行参数
  * 读取参数
    ```shell
    # $0程序名，$1到$9参数

    #!/bin/bash
    # using one command line parameter
    #
    factorial=1
    for (( number = 1; number <= $1; number++ ))
    do
        factorial=$[ $factorial * $number ]
    done
    echo The factorial of $1 is $factorial

    chmod u+x test1.sh
    ./test1.sh 5

    #!/bin/bash
    # testing two command line parameters
    #
    total=$[ $1 * $2 ]
    echo The first parameter is $1.
    echo The second parameter is $2.
    echo The total value is $total.

    chmod u+x test2.sh
    ./test2.sh 2 5

    #!/bin/bash
    # testing string parameters
    #
    echo Hello $1, glad to meet you.

    chmod u+x test3.sh
    ./test3.sh 'Rich Blum'
    ./test3.sh "Rich Blum"

    #!/bin/bash
    # handling lots of parameters
    #
    total=$[ ${10} * ${11} ]
    echo The tenth parameter is ${10}
    echo The eleventh parameter is ${11}
    echo The total is $total

    chmod u+x test4.sh
    ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12
    # 超过9个，变量名后加花括号
    ```
  * 读取脚本名
    ```shell
    #!/bin/bash
    # Testing the $0 parameter
    #
    echo The zero parameter is set to: $0
    #

    chmod u+x test5.sh
    bash test5.sh
    ./test5.sh
    bash /home/Christine/test5.sh

    #!/bin/bash
    # Using basename with the $0 parameter
    #
    name=$(basename $0)
    echo
    echo The script name is: $name
    #

    chmod u+x test5b.sh
    bash /home/Christine/test5b.sh
    ./test5b.sh

    #!/bin/bash
    # Testing a Multi-function script
    #
    name=$(basename $0)
    #
    if [ $name = "addem" ]
    then
        total=$[ $1 + $2 ]
    #
    elif [ $name = "multem" ]
    then
        total=$[ $1 * $2 ]
    fi
    #
    echo
    echo The calculated value is $total
    #

    cp test6.sh addem
    chmod u+x test6.sh
    chmod u+x addem
    ln -s test6.sh multem
    ls -l *em
    ./addem 2 5
    ./multem 2 5
    ```
  * 测试参数
    ```shell
    #!/bin/bash
    # testing parameters before use
    #
    if [ -n "$1" ]
    then
        echo Hello $1, glad to meet you.
    else
        echo "Sorry, you did not identify yourself."
    fi

    chmod u+x test7.sh
    ./test7.sh Rich
    ./test7.sh
    ```
* 特殊参数变量
  * 参数统计
    ```shell
    #!/bin/bash
    # getting the number of parameters
    #
    echo There were $# parameters supplied.

    chmod u+x test8.sh
    ./test8.sh
    ./test8.sh 1 2 3 4 5
    ./test8.sh 1 2 3 4 5 6 7 8 9 10
    ./test8.sh "Rich Blum"

    #!/bin/bash
    # Testing parameters
    #
    if [ $# -ne 2 ]
    then
        echo
        echo Usage: test9.sh a b
        echo
    else
        total=$[ $1 + $2 ]
        echo
        echo The total is $total
        echo
    fi

    bash test9.sh
    bash test9.sh 10
    bash test9.sh 10 15

    #!/bin/bash
    # testing grabbing last parameter
    #
    echo The last parameter was ${$#}

    chmod u+x badtest1.sh
    ./badtest1.sh

    #!/bin/bash
    # Grabbing the last parameter
    #
    params=$#
    echo
    echo The last parameter is $params 
    echo The last parameter is ${!#} # 返回命令脚本名
    echo

    bash test10.sh 1 2 3 4 5
    bash test10.sh
    ```
  * 抓取所有数据
    ```shell
    # $*所有参数当做一个单词保存
    # $@所有参数当做同一字符串的多个独立单词

    #!/bin/bash
    # testing $* and $@
    #
    echo
    echo "Using the \$* method: $*"
    echo
    echo "Using the \$@ method: $@"

    chmod u+x test11.sh
    ./test11.sh rich barbara katie jessica

    #!/bin/bash
    # testing $* and $@
    #
    echo
    count=1
    #
    for param in "$*"
    do
        echo "\$* Parameter #$count = $param"
        count=$[ $count + 1 ]
    done
    #
    echo
    count=1
    #
    for param in "$@"
    do
        echo "\$@ Parameter #$count = $param"
        count=$[ $count + 1 ]
    done

    chmod u+x test12.sh
    ./test12.sh rich barbara katie jessica
    ```
* 移动变量
  ```shell
  #!/bin/bash
  # demonstrating the shift command
  echo
  count=1
  while [ -n "$1" ]
  do
      echo "Parameter #$count = $1"
      count=$[ $count + 1 ]
      shift
  done

  chmod u+x test13.sh
  ./test13.sh rich barbara katie jessica

  #!/bin/bash
  # demonstrating a multi-position shift
  #
  echo
  echo "The original parameters: $*"
  shift 2
  echo "Here's the new first parameter: $1"

  chmod u+x test14.sh
  ./test14.sh 1 2 3 4 5
  ```
* 处理选项
  * 查找选项
    * 处理简单选项
      ```shell
      #!/bin/bash
      # extracting command line options as parameters
      #
      echo
      while [ -n "$1" ]
      do
          case "$1" in
              -a) echo "Found the -a option";;
              -b) echo "Found the -b option";;
              -c) echo "Found the -c option";;
              *) echo "$1 is not an option";;
          esac
          shift
      done

      chmod u+x test15.sh
      ./test15.sh -a -b -c -d
      ./test15.sh -d -c -a
      ```
    * 分离参数和选项
      ```shell
      #!/bin/bash
      # extracting options and parameters
      echo
      while [ -n "$1" ]
      do
          case "$1" in
              -a) echo "Found the -a option";;
              -b) echo "Found the -b option";;
              -c) echo "Found the -c option";;
              --) shift
                  break ;;
              *) echo "$1 is not an option";;
          esac
          shift
      done
      #
      count=1
      for param in $@
      do
          echo "Parameter #$count: $param"
          count=$[ $count + 1 ]
      done

      chmod u+x test16.sh
      ./test16.sh -c -a -b test1 test2 test3
      ./test16.sh -c -a -b -- test1 test2 test3
      ```
    * 处理带值的选项
      ```shell
      #!/bin/bash
      # extracting command line options and values
      echo
      while [ -n "$1" ]
      do
          case "$1" in
              -a) echo "Found the -a option";;
              -b) param="$2"
                  echo "Found the -b option, with parameter value $param"
                  shift ;;
              -c) echo "Found the -c option";;
              --) shift
                  break ;;
              *) echo "$1 is not an option";;
          esac
          shift
      done
      #
      count=1
      for param in "$@"
      do
          echo "Parameter #$count: $param"
          count=$[ $count + 1 ]
      done

      chmod u+x test17.sh
      ./test17.sh -a -b test1 -d
      ./test17.sh -b test1 -a -d
      ```
  * 使用getopt命令
    * 命令的格式
      ```shell
      getopt optstring parameters # 格式
      getopt ab:cd -a -b test1 -cd test2 test3
      getopt -q ab:cd -a -b test1 -cde test2 test3 # 不在optstring选项产生错误消息，-q忽略
      ```
    * 在脚本中使用getopt
      ```shell
      #!/bin/bash
      # Extract command line options & values with getopt
      #
      set -- $(getopt -q ab:cd "$@")
      #
      echo
      while [ -n "$1" ]
      do
          case "$1" in
              -a) echo "Found the -a option";;
              -b) param="$2"
                  echo "Found the -b option, with parameter value $param"
                  shift ;;
              -c) echo "Found the -c option";;
              --) shift
                  break ;;
              *) echo "$1 is not an option";;
          esac
          shift
      done
      #
      count=1
      for param in "$@"
      do
          echo "Parameter #$count: $param"
          count=$[ $count + 1 ]
      done
      #

      chmod u+x test18.sh
      ./test18.sh -ac
      ./test18.sh -a -b test1 -cd test2 test3 test4
      ./test18.sh -a -b test1 -cd "test2 test3" test4 # 将空格当成参数分隔符
      ```
  * 使用更高级的getopts
    ```shell
    getopts optstring variable # 格式
    # optstring要求参数值,加冒号;去掉错误消息在optstring前加冒号
    # OPTARG保存参数值;OPTIND保存参数位置

    #!/bin/bash
    # simple demonstration of the getopts command
    #
    echo
    while getopts :ab:c opt
    do
        case "$opt" in
            a) echo "Found the -a option";;
            b) echo "Found the -b option, with parameter value $OPTARG";;
            c) echo "Found the -c option";;
            *) echo "Unknown option: $opt";;
        esac
    done

    chmod u+x test19.sh
    ./test19.sh -ab test1 -c
    ./test19.sh -b "test1 test2" -a # 参数包含空格
    ./test19.sh -abtest1 # 将选项字母和参数值放一起，不用加空格
    ./test19.sh -d # 将未定义选项输出为？
    ./test19.sh -acde

    #!/bin/bash
    # Processing options & parameters with getopts
    #
    echo
    while getopts :ab:cd opt
    do
        case "$opt" in
            a) echo "Found the -a option";;
            b) echo "Found the -b option, with parameter value $OPTARG";;
            c) echo "Found the -c option";;
            d) echo "Found the -d option";;
            *) echo "Unknown option: $opt";;
        esac
    done
    #
    shift $[ $OPTIND - 1 ]
    #
    echo
    count=1
    for param in "$@"
    do
        echo "Parameter $count: $param"
        count=$[ $count + 1 ]
    done
    #

    chmod u+x test20.sh
    ./test20.sh -a -b test1 -d test2 test3 test4
    ```
* 将选项标准化
* 获得用户输入
  * 基本的读取
    ```shell
    #!/bin/bash
    # testing the read command
    #
    echo -n "Enter your name: "
    read name
    echo "Hello $name, welcome to my program. "
    #

    chmod u+x test21.sh
    ./test21.sh

    #!/bin/bash
    # testing the read -p option
    #
    read -p "Please enter your age: " age
    days=$[ $age * 365 ]
    echo "That makes you over $days days old! "
    #

    chmod u+x test22.sh
    ./test22.sh # read -p指定提示符

    #!/bin/bash
    # entering multiple variables
    #
    read -p "Enter your name: " first last
    echo "Checking data for $last, $first..."

    chmod u+x test23.sh
    ./test23.sh

    #!/bin/bash
    # Testing the REPLY Environment variable
    #
    read -p "Enter your name: "
    echo
    echo Hello $REPLY, welcome to my program.
    #

    chmod u+ test24.sh
    ./test24.sh
    ```
  * 超时
    ```shell
    #!/bin/bash
    # timing the data entry
    #
    if read -t 5 -p "Please enter your name: " name
    then
        echo "Hello $name, welcome to my script"
    else
        echo
        echo "Sorry, too slow! "
    fi

    chmod u+x test25.sh
    ./test25.sh
    ./test25.sh

    #!/bin/bash
    # getting just character of input
    #
    read -n1 -p "Do you want to continue [Y/N]? " answer # -n1统计输出字符数1
    case $answer in
    Y | y) echo
           echo "fine, continue on...";;
    N | n) echo
           echo OK, goodbye
           exit;;
    esac
    echo "This is the end of the script"

    chmod u+x test26.sh
    ./test26.sh
    ./test26.sh
    ```
  * 隐藏方式读取
    ```shell
    #!/bin/bash
    # hiding input data from monitor
    #
    read -s -p "Enter your password: " pass # -s 输入数据不显示(实际read将文本颜色设置成背景色)
    echo
    echo "Is your password really $pass? "

    chmod u+x test27.sh
    ./test27.sh 
    ```
  * 从文件中读取
    ```shell
    #!/bin/bash
    # reading data from a file
    #
    count=1
    cat test | while read line
    do
        echo "Line $count: $line"
        count=$[ $count + 1 ]
    done
    echo "Finished processing the file"

    cat test
    chmod u+x test28.sh
    ./test28.sh # 文件没有内容时，read命令退出并返回非零退出状态码
    ```

## 第15章 呈现数据
* 理解输入和输出
  * 标准文件描述符
    * STDIN
      ```shell
      cat
      cat < testfile
      ```
    * STDOUT
      ```shell
      ls -l > test2
      cat test2
      who >> test2
      cat test2
      ls -al badfile > test2
      cat test3
      ```
    * STDERR
  * 重定向错误
    * 只重定向错误
      ```shell
      ls -al badfile 2> test4
      cat test4

      ls -al test badtest test2 2> test5
      cat test5
      ```
    * 重定向错误和数据
      ```shell
      ls -al test test2 test3 badtest 2> test6 1> test7 # 将STDERR和STDOUT输出重定向到不同输出文件
      cat test6
      cat test7

      ls -al test test2 test3 badtest &> test7 # &>将STDERR和STDOUT输出重定向到同一个输出文件
      cat test7
      ```
* 在脚本中重定向输出
  * 临时重定向
    ```shell
    echo "This is an error message" >&2 # 输出信息重定向到STDERR文件描述符
    #!/bin/bash
    # testing STDERR messages
    echo "This is an error" >&2
    echo "This is normal output"

    chmod u+x test8
    ./test8
    ./test8 2> test9
    cat test9
    ```
  * 永久重定向
    ```shell
    #!/bin/bash
    # redirecting all output to a file
    exec 1>testout
    echo "This is a test of redirecting all output"
    echo "from a script to another file."
    echo "without having to redirect every individual line"

    chmod u+x test10
    ./test10
    cat testout

    #!/bin/bash
    # redirecting output to different location
    exec 2>testerror
    echo "This is the start of the script"
    echo "now redirecting all output to another location"
    exec 1>testout
    echo "This output should go to the testout file"
    echo "but this should go to the testerror file" >&2

    chmod u+x test11
    ./test11
    cat testout
    cat testerror
    ```
* 在脚本中重定向输入
  ```shell
  exec 0< testfile

  #!/bin/bash
  # redirecting file input
  exec 0< testfile
  count=1
  while read line
  do
      echo "Line #$count: $line"
      count=$[ $count + 1 ]
  done

  chmod u+x test12
  ./test12
  ```
* 创建自己的重定向
  * 创建输出文件描述符
    ```shell
    #!/bin/bash
    # using an alternative file descriptor
    exec 3>test13out
    echo "This should display on the monitor"
    echo "and this should be stored in the file" >&3
    echo "Then this should be back on the monitor"

    chmod u+x test13
    ./test13
    cat test13out

    exec 3>>test13out # 将输出追加到现有文件
    ```
  * 重定向文件描述符
    ```shell
    #!/bin/bash
    # storing STDOUT, then coming back to it
    exec 3>&1
    exec1 >test14out
    echo "This should store in the output file"
    echo "along with this line."
    exec 1>&3
    echo "Now things should be back to normal"

    chmod u+x test14
    ./test14
    cat test14out
    ```
  * 创建输入文件描述符
    ```shell
    #!/bin/bash
    # redirecting input file descriptors
    exec 6<&0
    exec 0< testfile
    count=1
    while read line
    do
        echo "Line #$count: $line"
        count=$[ $count + 1 ]
    done
    exec 0<&6
    read -p "Are you done now? " answer
    case $answer in
    Y|y) echo "Goodbye";;
    N|n) echo "Sorry, this is the end.";;
    esac

    chmod u+x test15
    ./test15
    ```
  * 创建读写文件描述符
    ```shell
    #!/bin/bash
    # testing input/output file descriptor
    exec 3<> testfile
    read line <&3
    echo "Read: $line"
    echo "This is a test line" >&3

    chmod u+x test16
    cat testfile
    ./test16
    cat testfile
    ```
  * 关闭文件描述符
    ```shell
    #!/bin/bash
    # testing closing file descriptors
    exec 3> test17file
    echo "This is a test line of data" >&3
    exec 3>&-
    echo "This won't work" >&3

    chmod u+x badtest
    ./badtest

    #!/bin/bash
    # testing closing file descriptors
    exec 3> test17file
    echo "This is a test line of data" >&3
    exec 3>&-
    cat test17file
    exec 3> test17file
    echo "This'll be bad" >&3

    chmod u+x test17
    ./test17
    cat test17file
    ```
* 列出打开的文件描述符
  ```shell
  /usr/sbin/lsof # 普通用户运行通过全路径名引用
  /usr/sbin/lsof -a -p $$ -d 0,1,2 # -p指定进程ID(PID),当前PID用$$;-d显示文件描述符编号；-a对其他两个选项结果执行布尔AND运算

  #!/bin/bash
  # testing lsof with file descriptors
  exec 3> test18file1
  exec 6> test18file2
  exec 7< testfile
  /usr/sbin/lsof -a -p $$ -d0,1,2,3,6,7

  chmod u+x test18
  ./test18
  ```
* 阻止命令输出
  ```shell
  ls -al > /dev/null
  cat /dev/null

  ls -al badfile test16 2> /dev/null

  cat testfile
  cat /dev/null > testfile
  cat testfile
  ```
* 创建临时文件
  * 创建本地临时文件
    ```shell
    mktemp testing.XXXXXX
    ls -al testing*
    mktemp testing.XXXXXX
    mktemp testing.XXXXXX
    mktemp testing.XXXXXX
    ls -l testing*

    #!/bin/bash
    # creating and using a temp file
    tempfile=$(mktemp test19.XXXXXX)
    exec 3>$tempfile
    echo "This script writes to temp file $tempfile"
    echo "This is the first line" >&3
    echo "This is the second line." >&3
    echo "This is the last line." >&3
    exec 3>&-
    echo "Done creating temp file. the contents are:"
    cat $tempfile
    rm -f $tempfile 2> /dev/null

    chmod u+x test19
    ./test19
    ```
  * 在/tmp目录创建临时文件
    ```shell
    mktemp -t test.XXXXXX
    ls -al /tmp/test*

    #!/bin/bash
    # creating a temp file in /tmp
    tempfile=$(mktemp -t tmp.XXXXXX) # -t强制mktemp在系统临时目录创建文件，返回创建临时文件的全路径
    echo "This is a test file." > $tempfile
    echo "This is the second line of the test." >> $tempfile
    echo "The temp file is located at: $tempfile"
    cat $tempfile
    rm -f $tempfile

    chmod u+x test20
    ./test20
    ```
  * 创建临时目录
    ```shell
    #!/bin/bash
    # uing a temporary directory
    tempdir=$(mktemp -d dir.XXXXXX)
    cd $tempdir
    tempfile1=$(mktemp temp.XXXXXX)
    tempfile2=$(mktemp temp.XXXXXX)
    exec 7> $tempfile1
    exec 8> $tempfile2
    echo "Sending data to directory $tempdir"
    echo "This is a test line of data for $tempfile1" >&7
    echo "This is a test line of data for $tempfile2" >&8

    chmod u+x test21
    ./test21
    ls -al
    cd dir.ouT8S8
    ls -al
    cat temp.N5F3O6
    cat temp.SQslb7
    ```
* 记录消息
  ```shell
  tee filename
  date | tee testfile
  cat testfile
  who | tee testfile # tee每次使用覆盖输出文件内容
  cat testfile
  date | tee -a  testfile # -a追加数据
  cat testfile

  #!/bin/bash
  # using the tee command for logging
  tempfile=test22file
  echo "This is the start of the test" | tee $tempfile
  echo "This is the second of the test" | tee -a $tempfile
  echo "This is the end of the test" | tee -a $tempfile

  chmod u+x test22
  ./test22
  cat test22file
  ```
* 实例
  ```shell
  #!/bin/bash
  # read file and create INSERT statements for MySQL
  outfile='members.sql'
  IFS=','
  while read lname fname address city state zip
  do
      cat >> $outfile << EOF
      INSERT INTO members (lname,fname,address,city,state,zip) VALUES
  ('$lname', '$fname', '$address', '$city', '$state', '$zip');EOF
  done < ${1}

  chmod u+x test23
  cat members.csv
  ./test23 members.csv
  # EOF标记追加到文件中的数据的起止
  ```

## 第16章 控制脚本
* 处理信号
  * 重温Linux信号
  * 生成信号
    ```shell
    # 中断进程 Ctrl+C生成SIGINT信号，停止shell中当前运行的进程

    # 暂停进程 Ctrl+Z生成SIGTSTP信号，停止shell中运行的进程
    ```
  * 捕获信号
    ```shell
    trap commands signals # 指定shell脚本要监看并从shell中拦截的Linux信号

    #!/bin/bash
    # Testing signal trapping
    #
    trap "echo ' Sorry! I have trapped Ctrl-C'" SIGINT
    #
    echo This is a test script
    #
    count=1
    while [ $count -le 10 ]
    do
        echo "Loop #$count"
        sleep 1
        count=$[ $count + 1 ]
    done
    #
    echo "This is the end of the test script"
    #

    chmod u+x test1.sh
    ./test1.sh
    ```
  * 捕获脚本退出
    ```shell
    #!/bin/bash
    # Trapping the script exit
    #
    trap "echo Goodbye..." EXIT
    #
    count=1
    while [ $count -le 5 ]
    do
        echo "Loop #$count"
        sleep 1
        count=$[ $count + 1 ]
    done
    #

    chmod u+x test2.sh
    ./test2.sh
    ```
  * 修改或移除捕获
    ```shell
    #!/bin/bash
    # Modifying a set trap
    #
    trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT
    #
    count=1
    while [ $count -le 5 ]
    do
        echo "Loop #$count"
        sleep 1
        count=$[ $count + 1 ]
    done
    #
    trap "echo ' I modified the trap!'" SIGINT
    #
    count=1
    while [ $count -le 5 ]
    do
        echo "Second Loop #$count"
        sleep 1
        count=$[ $count + 1 ]
    done
    #

    chmod u+x test3.sh
    ./test3.sh

    #!/bin/bash
    # Removing a set trap
    #
    trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT
    #
    count=1
    while [ $count -le 5 ]
    do
        echo "Loop #$count"
        sleep 1
        count=$[ $count + 1 ]
    done
    #
    # Remove the trap
    trap -- SIGINT
    echo "I just removed the trap"
    #
    count=1
    while [ $count -le 5 ]
    do
        echo "Second Loop #$count"
        sleep 1
        count=$[ $count + 1 ]
    done
    #

    chmod u+x test3b.sh
    ./test3b.sh
    ```
* 以后台模式运行脚本
  * 后台运行脚本
    ```shell
    #!/bin/bash
    # Testing running in the background
    #
    count=1
    while [ $count -le 10 ]
    do
        sleep 1
        count=$[ $count + 1 ]
    done
    #

    chmod u+x test4.sh
    ./test4.sh & # &后台模式运行shell

    #!/bin/bash
    # Testing running in the background with output
    #
    echo "Start the test script"
    count=1
    while [ $count -le 5 ]
    do
        echo "Loop #$count"
        sleep 5
        count=$[ $count + 1 ]
    done
    #
    echo "Test script is complete"
    #

    chmod u+x test5.sh
    ./test5.sh &
    ```
  * 运行多个后台作业
    终端使用后台进程，终端退出后台进程也退出
* 在非控制台下运行脚本
  ```shell
  nohup ./test1.sh & # nohup运行另一个命令阻断所有发给该进程的SIGHUP信号，退出终端会话阻止进程退出
  cat nohup.out # nohup将STDOUT和STDERR重定向到nohup.out文件中
  ```
* 作业控制
  * 查看作业
    ```shell
    #!/bin/bash
    # Test job control
    #
    echo "Script Process ID: $$"
    #
    count=1
    while [ $count -le 10 ]
    do
        echo "Loop #$count"
        sleep 10
        count=$[ $count + 1 ]
    done
    #
    echo "End of script..."
    #

    chmod u+x test10.sh
    ./test10.sh
    ./test10.sh > test10.out &
    jobs # 查看shell作业
    jobs -l # -l查看作业PID
    ```
  * 重启停止的作业
    ```shell
    ./test11.sh
    bg
    jobs
    ./test11.sh
    ./test11.sh
    bg 2 # 后台模式重启作业
    jobs
    fg 2 #前台模式重启作业
    ```
* 调控谦让度
  * nice命令
    ```shell
    nice -n 10 ./test4.sh > test4.out &
    ps -p 4973 -o pid,ppid,ni,cmd # NI谦让度值
    nice -n -10 ./test4.sh > test4.out & # nice命令阻止普通用户提高命令优先级
    nice -10 ./test4.sh > test4.out & # -n选项不是必须，破折号后加优先级
    ps -p  -o pid,ppid,ni,cmd
    ```
  * renice命令
    ```shell
    ./test11.sh &
    ps -p 5055 -o pid,ppid,ni,cmd
    renice -n 10 -p 5055 # 改变系统已运行命令优先级
    ps -p 5055 -o pid,ppid,ni,cmd
    ```
* 定时作业
  * 用at命令来计划执行作业
    ```shell
    at [-f filename] time # -q指定不同队列字母

    #!/bin/bash
    # Test using at command
    #
    echo "This script ran at $(date +%B%d,%T)"
    echo
    sleep 5
    echo "This is the script's end..."
    #

    at -f test13.sh now

    #!/bin/bash
    # Test using at command
    #
    echo "This script ran at $(date +%B%d,%T)" > test13b.out
    echo >> test13b.out
    sleep 5
    echo "This is the script's end..." >> test13b.out

    at -M -f test13b.sh now # 不想at使用邮件或重定向，-M屏蔽作业产生的输出信息
    cat test13b.out

    at -M -f test13b.sh teatime
    at -M -f test13b.sh tomorrow
    at -M -f test13b.sh 13:30
    at -M -f test13b.sh now
    atq # 查看系统中哪些作业在等待

    atq
    atrm 18 # 删除作业
    atq
    ```
  * 安排需要定期执行的脚本
    ```shell
    # cron时间表
    min hour dayofmonth month dayofweek command
    15 10 * * * command # 每个月每天10:15执行命令
    15 16 * * 1 command # 每周一4:15 PM运行命令
    00 12 1 * * command # 每个月第一天中午12点执行命令
    15 10 * * * /home/rich/test4.sh > test4out

    # 构建cron时间表
    crontab -l # -l列出已有时间表-e时间表添加条目

    # 浏览cron目录
    ls /etc/cron.*ly # 脚本复制到daily目录，cron每天执行它

    # anacron程序
    sudo cat /var/spool/anacron/cron.monthly # 时间戳文件
    sudo cat /etc/anacrontab  # anacron使用自己的时间表检查目录
    period delay identifier command # anacron时间表基本格式
                                    # period定义作业多久运行一次已天为单位
                                    # delay指定系统启动后anacron等待多少分钟开始运行错过的脚本
    ```
  * 使用新shell启动脚本
